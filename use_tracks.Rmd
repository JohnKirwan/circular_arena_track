---
title: "Use Animal Tracks"
author: "
John Kirwan"
date: "30/6/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

### Get data from animal tracks

```{r message=FALSE, warning=FALSE}
library('tidyverse')
library('magrittr')
library('circular')
library('RColorBrewer')
```

Uses stimulus centre and point opposite stimulus centre as markers for the unit circle on arena. Gets complete track from each set of trials, makes a plot and determines headings.

```{r}
#folder <- 'F:/sci/PhD/Urchins/Diadema/Tenerife-2016/tracks/'
folder <- 'tracks/'
filez  <- list.files(normalizePath(folder))
# files_df  <- tibble(landmark=list.files(normalizePath(folder))[
#                     grep('*point01.txt$',list.files(normalizePath(folder)))],
#                     track=list.files(normalizePath(folder))[
#                       grep('*point02.txt$',list.files(normalizePath(folder)))])

files_df <- tibble(basename=sub("*_point01.txt", "",  #subset string before exp
                     list.files(normalizePath(folder))[
                     grep('*point01.txt$',list.files(normalizePath(folder)))]))

files_df %<>% mutate(landmark=paste0(basename,"_point01.txt"),
                    track    =paste0(basename,"_point02.txt"))

tail(files_df)
```


```{r}
# are there any (predicted) track names not represented in the file list?
# i.e. landmark files without a matching track file
if(any(!files_df$track    %in% list.files(normalizePath(folder)))){
  stop(print(paste0("The following track file is missing:",
    files_df$track[which(!files_df$track %in% list.files(normalizePath(folder)))]
                    )))
}

# are any track files in the file list without a match in the landmark files?
if(any(!list.files(normalizePath(folder))[grep('*point02.txt$',list.files(
           normalizePath(folder)))] %in% files_df$track)){
  stop(print(paste0("The following track file lacks a counterpart:",
    list.files(normalizePath(folder))[grep('*point02.txt$',list.files(
      normalizePath(folder)))]
        
                    )))
}
```

Try with first file to get the track

```{r}
animal_track = read.delim(normalizePath(paste0(folder,'/',files_df$track[1])),
                          sep="\t", header = FALSE)[,1:3]
names(animal_track) <- c("frame","x","y")
head(animal_track)
```

Try with first file to get the landmarks

```{r}
landmarks = read.delim(normalizePath(paste0(folder,'/',files_df$landmark[1])),
                          sep="\t", header = FALSE)[,1:3]
names(landmarks) <- c("frame","x","y")
head(landmarks)

if(length(landmarks$x) %% 2 == 1){ warning("Odd number of landmarks!") }

num_trials = length(landmarks$x)/2 
```


## The files 

With the assignment pipe *%<>%*, the variable is assigned to itself at the end.The radius of the circle based on the stimulus distance is *r_px*. atan2 outputs angles in radians according to the unit cicle from -pi to pi.

The y values of the landmark and tracks have been reversed to run upwards rather than downwards.

*stim_x_0* and *stim_y_0* are cartesian coords which have there location translated by subtracting the origin and the length scaled to the distance from the origin (and points transformed accordingly).

```{r}
get_trial_limits <- function(landmarks,animal_track,file_tbl,vid_num){ #,

 num_trials = dim(landmarks)[1]/2 # count number of trials
 # pick out start frame and centre and stimulus coords
 tl <- as_tibble(array(0,dim=c(num_trials,16),
    dimnames = list(NULL, c("first_f","orig_x","orig_y","stim_x","stim_y",
    "last_f","stim_x_0","stim_y_0","stim_theta","r_px","quadrant","video",
    "x0","y0","x1","y1"))), 
    .name_repair="unique")
  tl$video <- as.character(tl$video)
  
  landmarks$y <- - landmarks$y # invert y axis to read from bottom to top
  
  i = 1 
 while (i <= num_trials){ # for each trial
  tl$first_f[i]<- as.numeric(landmarks[(i*2)-1,1])# trial i start frame
  tl$orig_x[i] <- as.numeric(landmarks[(i*2)-1,2])# trial i centre pt x,y
  tl$orig_y[i] <- as.numeric(landmarks[(i*2)-1,3])# trial i centre pt x,y
  tl$stim_x[i] <- as.numeric(landmarks[i*2,2])# trial i stim centre x,y
  tl$stim_y[i] <- as.numeric(landmarks[i*2,3])# trial i stim centre x,y
       if (i < num_trials){
        tl$last_f[i] <- as.numeric(landmarks[((i+1)*2)-1,1]-1)# trial i last frame
     } else { tl$last_f[i]  <- max(animal_track[,1]) } # max along dimension 1 
  i = i + 1
  }
  
  tl$stim_x_0 <- tl$stim_x - tl$orig_x # stimulus cart coords - orig
  tl$stim_y_0 <- tl$stim_y - tl$orig_y
  tl$stim_theta <- atan2(tl$stim_y_0,tl$stim_x_0) # 
  tl$r_px     <- sqrt((tl$stim_x_0)^2+(tl$stim_y_0)^2) # pixel radius
  tl$stim_x_0 <- tl$stim_x_0 / tl$r_px # standardize by the radius 
  tl$stim_y_0 <- tl$stim_y_0 / tl$r_px # standardize by the radius 

 i=1
 while (i <= num_trials){ 
    if (tl$stim_theta[i] > .25*pi & tl$stim_theta[i] <= .75*pi){
        tl$quadrant[i] = "top" #if stimulus in first quadrant
    }else if (tl$stim_theta[i]>= -.25*pi & tl$stim_theta[i] < .25*pi){
        tl$quadrant[i] = "left"
    }else if (tl$stim_theta[i] >= -.75*pi & tl$stim_theta[i] < -.25*pi ){
        tl$quadrant[i] = "bottom"
    }else {
        tl$quadrant[i] <- "right" } 
    i = i + 1
 }

 tl$video <- file_tbl[[vid_num,1]]
 return(tl)
}
```

#find each trial and get data
# (i) frame no (ii - v) coords for centre and stimulus (vi) last frame #
# (vii - viii) normalised stimulus centre (ix) theta in rads (anticlock,
# zero=0) (x) rho in pixels 

Get limits from first video

```{r}
trial_limits <- get_trial_limits(landmarks,animal_track,files_df,1) #
```


Divide the animal tracks up by trial using the first landmark. Initialize 
transformed tracks for later.

```{r Get animal pos fx}
get_animal_pos <- function(trial_limits,animal_track){
  num_trials = dim(trial_limits)[1] # count number of trials
  
  animal_track$y <- -animal_track$y # invert y so that runs from bottom up
  # make nested tibble of the sets
  trackz <- purrr::map(vector(length=num_trials), tibble)

 i <- 1 # initialize i  
 while (i <= dim(trial_limits)[1]){    # for each trial in a video 
   animal_track$trial_num[ animal_track$frame >= trial_limits$first_f[i] & 
        animal_track$frame <= trial_limits$last_f[i] ] <- i # get the trial no for each obs
   XY <- as_tibble(animal_track[animal_track$frame >= trial_limits$first_f[i] & 
           animal_track$frame <= trial_limits$last_f[i],]) # make a tibble of that trial
   XY %<>% add_column(trans_x=0,trans_y=0,trans_theta=0,trans_rho=0)
   XY[,5:6] <- sweep(XY[,2:3],2,as.numeric(trial_limits[i,2:3]),"-") # subtract origin
   XY[,5:6] <- XY[,5:6] / trial_limits$r_px[i]
   
   trans_theta <- mapply(atan2,XY[,6],XY[,5]) # polars for points
   trans_rho   <- sqrt(XY[,5]^2 + XY[,6]^2)
   
   XY[,7] <- trans_theta + (pi/2) - as.numeric(trial_limits[i,9]) # norm theta
   XY[,7] <- as.circular(XY[,7],type="angles",units="radians")
   XY[,8] <- trans_rho  #/as.numeric(trial_limits$r_px[i]) #normalised rho
   XY[,9] <- trial_limits[i,12]
   XY[,10]<- as.character(i) # order of trials in video
   colnames(XY)[10] <- "order" # order of trials in video
   XY$trans_theta[XY$trans_theta>pi] <- XY$trans_theta[XY$trans_theta>pi] - 2*pi
   XY %<>% unite("vid_ord", video:order,remove = FALSE)
   XY$rel_theta <- XY$trans_theta - trial_limits$stim_theta[i]
   XY$rel_theta[XY$rel_theta > pi] <- XY$rel_theta[XY$rel_theta > pi] - 2*pi

   trackz[[i]] <- XY
   # assign tracks less than 40% of arena to be empty
   if(min(XY[,8])>.4){trackz[[i]] <- "Track starts too far from centre"}
   if(any(XY[,8])> 1){warning('Track exceeds arena width!')}
   
#if(!any(XY[,8] < .25)){warning(paste0("Tracks begin >1/4 rad from centre for trial"))}
   trial_limits$x0[i] <- XY$trans_x[which.min(abs(XY$trans_rho - .25))]
   trial_limits$y0[i] <- XY$trans_y[which.min(abs(XY$trans_rho - .25))]
   trial_limits$x1[i] <- XY$trans_x[which.min(abs(XY$trans_rho - .5))]
   trial_limits$y1[i] <- XY$trans_y[which.min(abs(XY$trans_rho - .5))]
   trial_limits$vid_ord[i] <- paste0(trial_limits[i,12],"_",i)
   i = i + 1
 }
 #colnames(trial_limits)[17] <- "vid_ord"
 #trial_limits[,13:16] <- mapply('/',trial_limits[,13:16], trial_limits[,10])
 # norm to radius
 return(list(trackz,trial_limits))
}
```

Get the all the tracks from a single file. Print one set.

```{r}
trial_track_list   <- get_animal_pos(trial_limits,animal_track)
trackz             <- trial_track_list[[1]]
tail(trackz[[1]])
```

```{r}
trial_limits      <- trial_track_list[[2]]
tail(trial_limits)
```

Now apply this to all files.Then transform the coords from all tibbles in the big list.

```{r}
get_all_animal_pos <- function(landmarks,animal_track,files_df){
  i <- 1 # for all files in files_df
  while(i <= dim(files_df)[1]){
    animal_track = read.delim(normalizePath(paste0(folder,'/',files_df$track[i])),
                            sep="\t", header = FALSE)[,1:3]
    names(animal_track) <- c("frame","x","y")
    landmarks = read.delim(normalizePath(paste0(folder,'/',
                      files_df$landmark[i])),sep="\t", header = FALSE)[,1:3]
    names(landmarks) <- c("frame","x","y")
    if(length(landmarks$x) %% 2 == 1){ warning("Odd number of landmarks!") }
    trial_limits <- get_trial_limits(landmarks,animal_track,files_df,i) #
    trial_track_list <- get_animal_pos(trial_limits,animal_track) # run get_animal_pos
     if(i == 1){  
       all_trackz       <- trial_track_list[[1]] # populate with first list
       all_trial_limits <- trial_track_list[[2]] # first instance from above
     } else {
       all_trackz       <- c(all_trackz,trial_track_list[[1]])
       all_trial_limits <- rbind(all_trial_limits,trial_track_list[[2]])
    }
    i <- i + 1
  }
 trackz_n_limits <- list(all_trackz,all_trial_limits) 
 return(trackz_n_limits)
}
```


```{r}
trackz_n_limits  <- get_all_animal_pos(landmarks,animal_track,files_df)
all_trackz       <- trackz_n_limits[[1]]
tail(all_trackz[[1]])
```

```{r}
all_trial_limits <- trackz_n_limits[[2]]
all_trial_limits$stim_theta <- as.circular(all_trial_limits$stim_theta)
tail(all_trial_limits)
```
Delete those rows for which the first and second circles are the same.

```{r}
idx <- which(all_trial_limits$x0==all_trial_limits$x1 & all_trial_limits$y0==all_trial_limits$y1)
all_trackz[idx] <- NULL
all_trial_limits <- all_trial_limits[-c(idx),]
print(paste(length(all_trackz),"tracks post culling"))
print(paste(dim(all_trial_limits)[1],"trials in limits list post culling"))
```

Make tibble for tracks rather than list

```{r}
trackz_tbl <- map_dfr(all_trackz, ~ .x)
```


#### Line-Circle Intercept.

Works when vector intersects circle.

```{r}
linecirc <- function(x0,y0,x1,y1){
  h = 0;k=0;radius=1 # circle origin x,y
  a = (x1 - x0)^2 + (y1 - y0)^2 # vector length
  b = (2*(x1 - x0)*(x0 - h)) + (2*(y1 - y0)*(y0 - k)) # 
  c = (x0 - h)^2 + (y0 - k)^2 - radius^2
  D <- (b^2) - (4*a*c) # discriminant - must be positive
  if(a <= 0){warning("Vector length is not positive!")}
  if(D <= 0){warning(paste0(
    "Discriminant is not positive with x0=",x0," y0=",y0," x1=",x1," y1=",y1))}
  if(c >= 0){warning("Starting pt is outside radius!")}
  
  # the roots for t may be found in the usual quadratic form:
  t <- c(0,0)
  t[1] = (-b + sqrt(D)) / (2*a)
  t[2] = (-b - sqrt(D)) / (2*a) 
  # 1st and 2nd rows of ints correspond to 1st and 2nd root respectively
  ints <- rbind(unlist(c( t[1]*(x1 - x0) + x0, t[1]*(y1 - y0) + y0)),
                unlist(c( t[2]*(x1 - x0) + x0, t[2]*(y1 - y0) + y0)))
            
  d <- c(sqrt(ints[1,1]^2 + ints[1,2]^2),sqrt(ints[2,1]^2 + ints[2,2]^2))
  if(all.equal(d[1],d[2])==FALSE){warning("Intersect is off unit circle!")}
  # 1st and 2nd rows of dist2track correspond to 1st and 2nd root respectively
  dist2track    <- c(0,0) 
  dist2track[1] <- sqrt( (ints[1,1]-x1)^2 + (ints[1,2]-y1)^2 )
  dist2track[2] <- sqrt( (ints[2,1]-x1)^2 + (ints[2,2]-y1)^2 )
  xy <- ints[which.min(dist2track),]
  
  # commented because NAs crash this part
  #if(t[1] < 1 | t[2] > 0){ #which.min(dist2track)
  #  warning('Roots imply vector is weird') }
  return(tibble::tibble(x_int = xy[1],y_int = xy[2])) # return closest to outer pt
}
```

Get the headings from intersection with the unit circle.

Use atan2 to get the headings in radians. Then, having changed the class to circular, set them so that 0 refers to the stimulus midpoint and the rotation is clockwise. 

```{r}
intz <- pmap_dfr(list(
  all_trial_limits$x0,all_trial_limits$y0,
                    all_trial_limits$x1,all_trial_limits$y1), linecirc)

all_trial_limits$x_int <- intz$x_int
all_trial_limits$y_int <- intz$y_int

all_trial_limits$abs_rads <-mapply(atan2,
                                   all_trial_limits$y_int,all_trial_limits$x_int)

all_trial_limits$abs_rads <- as.circular(all_trial_limits$abs_rads, type="angles",
                            units="radians",zero=0,rotation="counter",
                            template="none", modulo="asis")

all_trial_limits$radians  <- all_trial_limits$abs_rads - all_trial_limits$stim_theta
all_trial_limits$radians[all_trial_limits$radians > pi] <- all_trial_limits$radians[
  all_trial_limits$radians > pi] - 2*pi

```

Temporary fix - remove observations with rho value greater than 1

```{r}
trackz_tbl <- trackz_tbl[trackz_tbl$trans_rho <= 1,]
```

#### Radian conversion

```{r}
## change top of arena to be at zero and rotation clockwise
all_trial_limits$abs_rads <- conversion.circular(
                            all_trial_limits$abs_rads, type="angles",
                            units="radians",zero=pi/2,rotation="clock",
                            template="none", modulo="asis")

all_trial_limits$radians <- conversion.circular(
                            all_trial_limits$radians, type="angles",
                            units="radians",zero=pi/2,rotation="clock",
                            template="none", modulo="asis")

# make the radians aligned to the top and rotation to be clockwise
trackz_tbl$trans_theta <- conversion.circular(
                            trackz_tbl$trans_theta, type="angles",
                            units="radians",zero=pi/2,rotation="clock",
                            template="none", modulo="asis")

# make the radians aligned to the top and rotation to be clockwise
trackz_tbl$rel_theta <- conversion.circular(
                            trackz_tbl$rel_theta, type="angles",
                            units="radians",zero=pi/2,rotation="clock",
                            template="none", modulo="asis")
```


Check which trails are also in df

```{r}
which(trackz_tbl$video %in% df$video)  # which track rows shares vid name with df
JEB18_tracks <- trackz_tbl[which(trackz_tbl$video %in% df$video),]
```


#### Plotting

*Points are plotting correctly although the zero and rotation are according to the unit circle becuase the points themselves are oriented that way, e.g. an upward pointing track has a heading of c.1.6.*

For some reason it appears to be using the conventional unit circle zero and rotation (points concentrated at x=1,y=0).

Later, use scale_colour_brewer(palette = "Paired")

#### Absolute position of tracks with regard to the arena (not the stimulus)

```{r}
circme <- circular::mean.circular(all_trial_limits$abs_rads)
R      <- circular::rho.circular (all_trial_limits$abs_rads)

# geom_path is already facing up, without (pi/2)- , geom_point() is not
JEB18_tracks %>% filter(video=="GOPR0243") %>%
  ggplot() + coord_fixed() +
  geom_path(aes(x=trans_x, y=trans_y,
                group=vid_ord,colour=vid_ord),
             alpha=0.3, size=.7) + 
  geom_point(aes(x=trans_x, y=trans_y,
                group=vid_ord,colour=vid_ord),
             alpha=0.1, size=1) +
  annotate("path", color="orange",
  x=0+1*cos(seq(0,2*pi,length.out=100)),y=0+1*sin(seq(0,2*pi,length.out=100))) +
  annotate("path", color="blue",
  x=0+.5*cos(seq(0,2*pi,length.out=100)),y=0+.5*sin(seq(0,2*pi,length.out=100))) +
  annotate("path", color="black",
  x=0+.25*cos(seq(0,2*pi,length.out=100)),y=0+.25*sin(seq(0,2*pi,length.out=100))) +
  geom_point(data=all_trial_limits, aes(x=x_int,    y=y_int),
             alpha=0.1, size=3) +
  xlab('') + ylab('') + theme_classic() + ggtitle('Plot all tracks simultaneously') +
  theme(axis.line=element_blank(),axis.ticks=element_blank(),
        axis.text=element_blank()) + theme(legend.position = "none") + 
  geom_segment(aes(x=0,y=0,xend=R*cos(circme),yend=R*sin(circme)),size=2)
```

#### Relative position of tracks with regard to the stimulus

```{r}
circme <- circular::mean.circular(all_trial_limits$radians)
R      <- circular::rho.circular (all_trial_limits$radians)

# geom_path is already facing up, without (pi/2)- , geom_point() is not
JEB18_tracks %>% filter(video=="GOPR0243") %>%
  ggplot() + coord_fixed() + 
  geom_path(aes(x=trans_rho*cos(((pi/2)-rel_theta)), #(pi/2)-
                y=trans_rho*sin(((pi/2)-rel_theta)), #(pi/2)-
                group=vid_ord,colour=vid_ord),
             alpha=0.3, size=.7) + 
  geom_point(aes(x=trans_rho*cos(rel_theta), #(pi/2)-
                 y=trans_rho*sin(rel_theta), #(pi/2)-
                group=vid_ord,colour=vid_ord),
             alpha=0.1, size=1) +
  annotate("path", color="orange",
  x=0+1*cos(seq(0,2*pi,length.out=100)),y=0+1*sin(seq(0,2*pi,length.out=100))) +
  annotate("path", color="blue",
  x=0+.5*cos(seq(0,2*pi,length.out=100)),y=0+.5*sin(seq(0,2*pi,length.out=100))) +
  annotate("path", color="black",
  x=0+.25*cos(seq(0,2*pi,length.out=100)),y=0+.25*sin(seq(0,2*pi,length.out=100))) +
  # Stick on final relative headings - not sure why it does't need pi/2 -
  geom_point(data=all_trial_limits,aes(x=cos(radians),y=sin(radians) ),
             alpha=0.1, size=3) +
  xlab('') + ylab('') + theme_classic() + ggtitle('Plot all tracks simultaneously') +
  theme(axis.line=element_blank(),axis.ticks=element_blank(),
        axis.text=element_blank()) + theme(legend.position = "none") + 
  geom_segment(aes(x=0,y=0,xend=R*cos(circme),yend=R*sin(circme)),size=2)
```



We will also need a means of plotting the original tracks normalized to the arena width but  not based on the stimulus position.


#### Bring in data frame with video names and trial order

```{r}
df <- read.delim('Diadema_tracks.txt', sep="\t", header = TRUE)
df %<>% filter(locale=="Tenerife")
df$locale   <- NULL
df$species  <- NULL

df$predator <- NULL
df$heading_rad <- as.circular(df$heading_rad,type="angles",units="radians",
                      zero=pi/2,rotation="clock", template="none",modulo="asis")
df$heading_rad[df$heading_rad>pi] <- df$heading_rad[df$heading_rad>pi] - 2*pi
head(df)
```


```{r}
circme <- circular::mean.circular(df$heading_rad)
R      <- circular::rho.circular(df$heading_rad)

df %>% filter(video=="GOPR0243") %>%
  ggplot() + coord_fixed() +
  annotate("path", color="orange",
  x=0+1*cos(seq(0,2*pi,length.out=100)),y=0+1*sin(seq(0,2*pi,length.out=100))) +
  geom_point(aes(x=1*cos((pi/2)-heading_rad),y=1*sin((pi/2)-heading_rad)),
             alpha=0.1, size=3) +
  xlab('') + ylab('') + theme_classic() + ggtitle('Plot all tracks simultaneously') +
  theme(axis.line=element_blank(),axis.ticks=element_blank(),
        axis.text=element_blank()) + theme(legend.position = "none") + 
  geom_segment(aes(x=0,y=0,xend=R*cos((pi/2)-circme),yend=R*sin((pi/2)-circme)),size=2)
```


Write the tracks to a file

```{r}
write_csv(trackz_tbl,  file = "tracks_file.csv")
write_delim(trackz_tbl,file = "tracks_file.txt",delim = "\t")
```

