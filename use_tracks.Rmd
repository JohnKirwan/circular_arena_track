---
title: "Use Animal Tracks"
author: "John Kirwan"
date: "30/6/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

### Get data from animal tracks

```{r message=FALSE, warning=FALSE}
library('tidyverse')
library('circular')
```


Uses stimulus centre and point opposite stimulus centre as markers for the unit circle on arena. Gets complete track from each set of trials, makes a plot and determines headings.

```{r}
folder <- 'D:/sci/PhD/Urchins/Diadema/Tenerife-2016/tracks/'
filez  <- list.files(normalizePath(folder))
files_df  <- tibble(landmark=list.files(normalizePath(folder))[
                    grep('*point01.txt$',list.files(normalizePath(folder)))],
                    track=list.files(normalizePath(folder))[
                      grep('*point02.txt$',list.files(normalizePath(folder)))])
tail(files_df)
```

**Come back to this is it is really important that they always match.**

```{r}
num <- 2
animal_track = read.delim(normalizePath(paste0(folder,'/',files_df$track[num])),
                          sep="\t", header = FALSE)[,1:3]
names(animal_track) <- c("frame","x","y")
head(animal_track)
```


```{r}
animal_landmark = read.delim(normalizePath(paste0(folder,'/',files_df$landmark[num])),
                          sep="\t", header = FALSE)[,1:3]
names(animal_landmark) <- c("frame","x","y")
head(animal_landmark)

if(length(animal_landmark$x) %% 2 == 1){ warning("Odd number of landmarks!") }

num_trials = length(animal_landmark$x)/2 
```

## The files 

With the assignment pipe *%<>%*, the variable is assigned to itself at the end.

```{r}
cart2rho <- function(x,y){
  rho    <- sqrt(x^2 + y^2)
  return(rho)
}

cart2theta <- function(x,y){
  theta  <- atan2(y,x)
  return(theta)
}

#function [trial_limits] = get_trial_limits(landmarks,animal_track)
get_trial_limits <- function(landmarks,animal_track){

  num_trials = dim(landmarks)[1]/2 # count number of trials
#trial_limits = zeros([num_trials 11]); # pick out start frame and centre and stimulus coords
  trial_limits <- array(dim=c(num_trials,11))
  #trial_limits <- as_tibble(trial_limits)
  colnames(trial_limits) <- c(
    "first_f","orig_x","orig_y","stim_x","stim_y","last_f",
    "norm_stim_x","norm_stim_y","theta","rho","quadrant")
#  trial_limits %>% mutate(across(.cols = everything(),as.numeric))
  cols(trial_limits = col_number())
  i = 1 
  
 while (i <= num_trials){ # for each trial
     trial_limits[i, 1  ] <- as.numeric(landmarks[(i*2)-1,  1]) # trial i start frame
     trial_limits[i, 2:3] <- as.numeric(landmarks[(i*2)-1,2:3]) # trial i centre point x and y
     trial_limits[i, 4:5] <- as.numeric(landmarks[i*2,    2:3]) # trial i stimulus centre x and y
    
     if (i < num_trials){
        trial_limits[i , 6] <- as.numeric(landmarks[((i+1)*2)-1,1] - 1)  # trial i last frame
     } else {
       j =  max(animal_track[,1]) # max along dimension 1 - which I tak to mean the 1st col
       trial_limits[i , 6] = j[1]
     }
 
     trial_limits[i , 7:8] <- as.numeric(trial_limits[i, 4:5] - trial_limits[i , 2:3]) 
# normalised stimulus centre in cartesian terms relative to centre of arena

#[theta1 , rho1] = cart2pol(trial_limits[i , 7], trial_limits[i,8]); 
     theta1 = atan2(trial_limits[i,8],trial_limits[i , 7]) # polars for stimulus centre
     rho1   = sqrt(trial_limits[i , 7]^2 + trial_limits[i,8]^2)
     
     theta1 = theta1 + pi/2; # set to conventional degree values with 0 at top and clockwise
     if (theta1 < 0){        
         theta1 = theta1 + pi*2;     
     }else if (theta1 > pi*2){   
         theta1 = theta1 - pi*2     
     }
     trial_limits[i , 9] = theta1; 
     trial_limits[i , 10] <- rho1 # theta in rads, rho in pixels

    if (trial_limits[i , 9] >= 0 & trial_limits[i , 9] < pi/4 | trial_limits[i , 9] > 1.75*pi){ 
     #if stimulus in first quadrant
        trial_limits[i , 11] = 1;
    }else if (trial_limits[i , 9] >= pi/4    & trial_limits[i , 9] < 0.75*pi ){
        trial_limits[i , 11] = 2;
    }else if (trial_limits[i , 9] >= 0.75*pi & trial_limits[i , 9] < 1.25*pi ){
        trial_limits[i , 11] = 3;
    }else if (trial_limits[i , 9] >= 1.25*pi & trial_limits[i , 9] < 1.75*pi ){
        trial_limits[i , 11] = 4;
    }    
    i = i + 1 
 }
 return(trial_limits)
}
```

#find each trial and get data
# (i) frame no (ii - v) coords for centre and stimulus (vi) last frame #
# (vii - viii) normalised stimulus centre (ix) theta in rads (anticlock,
# zero=0) (x) rho in pixels 

```{r}
trial_limits <- get_trial_limits(animal_landmark,animal_track)
```


Divide the animal tracks up by trial using the first landmark

```{r Get animal pos fx}
get_animal_pos <- function(trial_limits,animal_track){
  num_trials = dim(trial_limits)[1] # count number of trials
  i = 1             
  trackz = tibble(5, dim(animal_track)[1]) 
  colnames(trackz) <- c("video","trial","frame","x","y")
  trackz[,1]       <- rep(files_df$landmark[num],dim(animal_track)[1])
 
 while (i <= num_trials){              # for each set of trial starts                          
    track_x   = vector()
    track_y   = vector()   # empty vector for track xs and ys
#   track_x   = [trial_limits(i , 2)]; track_y   = [trial_limits(i , 3)] ;
#   to include origin
    h = 1; 
     
    while (h <= length(animal_track[,1])){                      
    # cycle through the frames
    j   = animal_track[h,1];                                   
    # pick the frame
    
        if (j >= trial_limits[i,1] & j <= trial_limits[i,6]){      
            # if in the bounds of a given trial
            track_x = c(track_x,animal_track[h,2])                
            # append x values for each trial
            track_y = c(track_y,animal_track[h,3])                
            # append y values for each trial
    }
        
    h = h + 1       
    trackz[i] = c(t(track_x), t(track_y)) #add to cell array for this trial
  }     
  i = i + 1       
    
 }      
 return(trackz)
}
```


```{r}
trackz       <- get_animal_pos(trial_limits,animal_track) 
```


```{r trackz_transform fx}
trackz_transform <- function(trackz,trial_limits){

 i = 1
 num_trials = size(trial_limits, 1) # count number of trials
 pre_tranz_trackz = cell(num_trials, 1) 
 
    while i <= num_trials ;                     # for each trial / cell array
    j = 1;
    
        while j <= length(trackz{i}) ;          # for each set of coords (row)
        
        pre_tranz_trackz_1{i}(j,1:2) = trackz{i}(j,1:2) - trial_limits(i,2:3) ; %subtract centre coords from x and y coords
        
        [theta , rho] = cart2pol(pre_tranz_trackz_1{i}(j,1),pre_tranz_trackz_1{i}(j,2)) ;
        pre_tranz_trackz_2{i}(j,1:2) = [theta rho] ; %subtract stimulus coords from x and y coords

        tranz_trackz{i}(j,1) =     (pre_tranz_trackz_2{i}(j,1) + (pi/2)) -     trial_limits(i,9)    ; %normalised theta
        tranz_trackz{i}(j,2) =      pre_tranz_trackz_2{i}(j,2) /     trial_limits(i,10)   ; %normalised rho
        
        if  tranz_trackz{i}(j,1) < (-2*pi)
            tranz_trackz{i}(j,1) = tranz_trackz{i}(j,1) + (4*pi);
        elseif tranz_trackz{i}(j,1) < 0
            tranz_trackz{i}(j,1) = tranz_trackz{i}(j,1) + (2*pi);
        end
             
        j = j + 1 ;
        end
 
    i = i + 1;
    end
  return(tranz_trackz)
}
```


```{r}
tranz_trackz <- trackz_transform(trackz,trial_limits)  # transform coords to origin and stimulus
```


# check that animal tracks start below 0.25 and increase

### Get animal track points closest to rho of 0.25 and 0.5 for each trial

```{r}
circleValues = zeros([length(trial_limits[,1]) 4])    

i = 1; 
while (i <= size(trial_limits, 1)) {

 [~, index] = min(abs(tranz_trackz{i}(:,2) - 0.25)) ;
 circleValues(i,1:2) = tranz_trackz{i}(index, 1:2)  ;
 
 [~, index] = min(abs(tranz_trackz{i}(:,2) - 0.5))  ;
 circleValues(i,3:4) = tranz_trackz{i}(index, 1:2)  ;
 
 i = i + 1  ;
 }
```

### Create cartesian vector from polar inner and outer circle coordinates 

```{r}
intersect_angle1 <- array(numeric(), c(num_trials,1))    
intersect_angle2 <- array(numeric(), c(num_trials,1)) 
which_intersect  <- array(numeric(), c(num_trials,1)) 
```

###JS: The next section was a bit hard to follow, so I cleaned it up a bit

```{r}
for(i = 1:num_trials){
    [inner_x, inner_y] = pol2cart(circleValues(i,1),circleValues(i,2));
    [outer_x, outer_y] = pol2cart(circleValues(i,3),circleValues(i,4));
    animal_vector(i, 1) = inner_x ;  animal_vector(i, 2) = inner_y ;
    animal_vector(i, 3) = outer_x ;  animal_vector(i, 4) = outer_y ;
    slope(i) = (outer_y - inner_y)/(outer_x - inner_x) ;
    animal_direction(i,1) = outer_x - inner_x;
    animal_direction(i,2) = outer_y - inner_y;
    intercept(i) = animal_direction(i,2) - slope(i) * animal_direction(i,1);
### JS: This was "- slope(i) * animal_direction(i,2);" but I believe it should be "- slope(i) * animal_direction(i,1);"
    [xout,yout] = linecirc(slope(i),intercept(i),0,0,1) ;
    circle_intersect(i, 1:2) = xout;
    circle_intersect(i, 3:4) = yout; # find x and y points where line intersects with circle

    #get polar coordinates of intersects
    [theta_target1, rho_target1] = cart2pol(circle_intersect(i,1),circle_intersect(i,3))   ;
    [theta_target2, rho_target2] = cart2pol(circle_intersect(i,2),circle_intersect(i,4))   ;
    intersect_angle1(i) = radtodeg(theta_target1) ; 
    intersect_angle2(i) = radtodeg(theta_target2) ;
        
    ### JS: Instead of the next section being a manual selection, you could
    ### automatically select the intersect that is closest to the outer circle
    ### crossing, e.g. like this:
    dist_to_track(1) = sqrt( (xout(1)-outer_x)^2 + (yout(1)-outer_y)^2 );
    dist_to_track(2) = sqrt( (xout(2)-outer_x)^2 + (yout(2)-outer_y)^2 );
    [~, which_intersect(i)] = min(dist_to_track);
}
```

Get angle for animal in each trial in degrees and put it in animal_angle

```{r}
animal_radian = zeros([num_trials 1]) ;
correct_intersect = zeros([num_trials 2]) ;
animal_angle = zeros([num_trials 1]) ;

for(i = 1:num_trials){
    if  (which_intersect(i) == 1){
        correct_intersect(i,1) = circle_intersect(i,1);
        correct_intersect(i,2) = circle_intersect(i,3);
    } else if (which_intersect(i) == 2){
        correct_intersect(i,1) = circle_intersect(i,2);
        correct_intersect(i,2) = circle_intersect(i,4);
    } else {
        error('Error, must be 1 or 2');
    }
    
    #add animals angle relative to stimulus centre to animal_angle
    animal_radian[i] = cart2pol(correct_intersect(i,1),correct_intersect(i,2));
    animal_angle[i]  = rad2deg(cart2pol(correct_intersect(i,1),correct_intersect(i,2)));
}
```


get the intersect of the tracks with the arena edge
<!-- get_track_intersect(landmarks,animal_track) ; -->

### Apply basic circular statistics to trials (uses radians)
 
<!-- trials_angle_mean = zeros([3 1]); -->
<!-- [mu ul ll] = circ_mean(animal_radian, [], 2) ; -->

```{r}
circ_labels = as.character(1:length(animal_radian));
directions  = circ_plot(animal_radian);
#tracks = circ_plot();
```

### Create csv output with trial number, position and direction in columns

```{r}
animal_radian_col[:,1] = t(animal_radian) ;
animal_radian_col[:,2] = circular::rad(t(animal_radian) ;

# C = {video_name, animal_radian_col[:,1], animal_radian_col[:,2]} ;
write_csv(animal_radian_col, paste0(video_name,''_directions.csv')
```




