---
title: "Use Animal Tracks"
author: "John Kirwan"
date: "30/6/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

### Get data from animal tracks

```{r message=FALSE, warning=FALSE}
library('tidyverse')
library('magrittr')
library('circular')
```


Uses stimulus centre and point opposite stimulus centre as markers for the unit circle on arena. Gets complete track from each set of trials, makes a plot and determines headings.

```{r}
folder <- 'F:/sci/PhD/Urchins/Diadema/Tenerife-2016/tracks/'
filez  <- list.files(normalizePath(folder))
# files_df  <- tibble(landmark=list.files(normalizePath(folder))[
#                     grep('*point01.txt$',list.files(normalizePath(folder)))],
#                     track=list.files(normalizePath(folder))[
#                       grep('*point02.txt$',list.files(normalizePath(folder)))])

files_df <- tibble(basename=sub("*_point01.txt", "",  #subset string before exp
                     list.files(normalizePath(folder))[
                     grep('*point01.txt$',list.files(normalizePath(folder)))]))

files_df %<>% mutate(landmark=paste0(basename,"_point01.txt"),
                    track    =paste0(basename,"_point02.txt"))

tail(files_df)
```


```{r}
# are there any (predicted) track names not represented in the file list?
# i.e. landmark files without a matching track file
if(any(!files_df$track    %in% list.files(normalizePath(folder)))){
  stop(print(paste0("The following track file is missing:",
    files_df$track[which(!files_df$track %in% list.files(normalizePath(folder)))]
                    )))
}

# are any track files in the file list without a match in the landmark files?
if(any(!list.files(normalizePath(folder))[grep('*point02.txt$',list.files(
           normalizePath(folder)))] %in% files_df$track)){
  stop(print(paste0("The following track file lacks a counterpart:",
    list.files(normalizePath(folder))[grep('*point02.txt$',list.files(
      normalizePath(folder)))]
        
                    )))
}
```

Try with first file to get the track

```{r}
animal_track = read.delim(normalizePath(paste0(folder,'/',files_df$track[1])),
                          sep="\t", header = FALSE)[,1:3]
names(animal_track) <- c("frame","x","y")
head(animal_track)
```

Try with first file to get the landmarks

```{r}
animal_landmark = read.delim(normalizePath(paste0(folder,'/',files_df$landmark[1])),
                          sep="\t", header = FALSE)[,1:3]
names(animal_landmark) <- c("frame","x","y")
head(animal_landmark)

if(length(animal_landmark$x) %% 2 == 1){ warning("Odd number of landmarks!") }

num_trials = length(animal_landmark$x)/2 
```

## The files 

With the assignment pipe *%<>%*, the variable is assigned to itself at the end.

```{r}
#function [trial_limits] = get_trial_limits(landmarks,animal_track)
get_trial_limits <- function(landmarks,animal_track,file_tbl,vid_num){ #,

  num_trials = dim(landmarks)[1]/2 # count number of trials
  #trial_limits = zeros([num_trials 11]); # pick out start frame and centre and stimulus coords
  trial_limits <- as_tibble(array(0,dim=c(num_trials,12)))
  
 colnames(trial_limits) <- c(
    "first_f","orig_x","orig_y","stim_x","stim_y","last_f",
    "norm_stim_x","norm_stim_y","theta","rho","quadrant","video")
  trial_limits$video <- as.character(trial_limits$video)
  i = 1 
  
 while (i <= num_trials){ # for each trial
   trial_limits[i, 1  ] <- as.numeric(landmarks[(i*2)-1,  1]) # trial i start frame
   trial_limits[i, 2:3] <- as.list(as.numeric(landmarks[(i*2)-1,2:3])) # trial i centre pt x,y
   trial_limits[i, 4:5] <- as.list(as.numeric(landmarks[i*2,    2:3])) # trial i stim centre x,y
    
     if (i < num_trials){
        trial_limits[i , 6] <- as.numeric(landmarks[((i+1)*2)-1,1] - 1)  # trial i last frame
     } else {
       j =  max(animal_track[,1]) # max along dimension 1 - which I tak to mean the 1st col
       trial_limits[i , 6] = j[1]
     }
 
     trial_limits[i , 7:8] <- as.list(as.numeric(trial_limits[i, 4:5] - trial_limits[i , 2:3])) 
     # normalised stimulus centre in cartesian terms relative to centre of arena

     #[theta1 , rho1] = cart2pol(trial_limits[i , 7], trial_limits[i,8]); 
     theta1 = atan2(trial_limits[[i,8]],trial_limits[[i , 7]]) # polars for stimulus centre
     rho1   = sqrt(trial_limits[[i, 7]]^2 + trial_limits[[i,8]]^2)
     
     theta1 = theta1 + pi/2; # set to conventional degree values with 0 at top and clockwise
     if (theta1 < 0){        
         theta1 = theta1 + pi*2;     
     }else if (theta1 > pi*2){   
         theta1 = theta1 - pi*2     
     }
     trial_limits[i , 9] = theta1; 
     trial_limits[i , 10] <- rho1 # theta in rads, rho in pixels

    if (trial_limits[i , 9] >= 0 & trial_limits[i , 9] < pi/4 | trial_limits[i , 9] > 1.75*pi){ 
     #if stimulus in first quadrant
        trial_limits[i , 11] = 1;
    }else if (trial_limits[i , 9] >= pi/4    & trial_limits[i , 9] < 0.75*pi ){
        trial_limits[i , 11] = 2;
    }else if (trial_limits[i , 9] >= 0.75*pi & trial_limits[i , 9] < 1.25*pi ){
        trial_limits[i , 11] = 3;
    }else if (trial_limits[i , 9] >= 1.25*pi & trial_limits[i , 9] < 1.75*pi ){
        trial_limits[i , 11] <- 4;
    }
    trial_limits[i, 12]      <- file_tbl[[vid_num,1]];
    i = i + 1 
 }
 return(trial_limits)
}
```

#find each trial and get data
# (i) frame no (ii - v) coords for centre and stimulus (vi) last frame #
# (vii - viii) normalised stimulus centre (ix) theta in rads (anticlock,
# zero=0) (x) rho in pixels 

Get limits from first video

```{r}
trial_limits <- get_trial_limits(animal_landmark,animal_track,files_df,1) #
```


Divide the animal tracks up by trial using the first landmark

```{r Get animal pos fx}
get_animal_pos <- function(trial_limits,animal_track){
  num_trials = dim(trial_limits)[1] # count number of trials
  
  # make nested tibble of the sets
  trackz <- purrr::map(vector(length=num_trials), tibble)

 i <- 1 # initialize i  
 while (i <= dim(trial_limits)[1]){    # for each trial in a video 
   animal_track$trial_num[ animal_track$frame >= trial_limits[[i,1]] & 
        animal_track$frame <= trial_limits[[i,6]] ] <- i # get the trial no for each obs
   XY <- as_tibble(animal_track[animal_track$frame >= trial_limits[[i,1]] & 
           animal_track$frame <= trial_limits[[i,6]],]) # make a tibble of that trial
   #XY[,5] <- trial_limits[[i,12]]
   trackz[[i]] <- XY
   i = i + 1
 }
 return(trackz)
}
```

Get the all the tracks from a single file. Print one set.

```{r}
trackz       <- get_animal_pos(trial_limits,animal_track)
tail(trackz[[1]])
```

Now apply this to all files.

```{r}
get_all_animal_pos <- function(animal_landmark,animal_track,files_df){
  # for all files in files_df
  i <- 1
  while(i <= dim(files_df)[1]){
    animal_track = read.delim(normalizePath(paste0(folder,'/',files_df$track[i])),
                            sep="\t", header = FALSE)[,1:3]
    names(animal_track) <- c("frame","x","y")
  
    animal_landmark = read.delim(normalizePath(paste0(folder,'/',
                      files_df$landmark[i])),sep="\t", header = FALSE)[,1:3]
    names(animal_landmark) <- c("frame","x","y")
    if(length(animal_landmark$x) %% 2 == 1){ warning("Odd number of landmarks!") }
  
    trial_limits <- get_trial_limits(animal_landmark,animal_track,files_df,i) #
  
    # run get_animal_pos
    if(i == 1){  
      all_trackz <- get_animal_pos(trial_limits,animal_track) # populate with first list
    } else {
      all_trackz <- c(all_trackz,get_animal_pos(trial_limits,animal_track))  
      }
    i <- i + 1
  }
 return(all_trackz)
}
```



```{r}
all_trackz <- get_all_animal_pos(animal_landmark,animal_track,files_df)
str(all_trackz)
```

Then make a function which tranforms the coords from all subtibbles

```{r trackz_transform fx}
trackz_transform <- function(trackz,trial_limits){

 i = 1
 num_trials = size(trial_limits, 1) # count number of trials
 pre_tranz_trackz = cell(num_trials, 1) 
 
    while i <= num_trials ;                     # for each trial / cell array
    j = 1;
    
        while j <= length(trackz{i}) ;          # for each set of coords (row)
        
        pre_tranz_trackz_1{i}(j,1:2) = trackz{i}(j,1:2) - trial_limits(i,2:3) ; %subtract centre coords from x and y coords
        
        [theta , rho] = cart2pol(pre_tranz_trackz_1{i}(j,1),pre_tranz_trackz_1{i}(j,2)) ;
        pre_tranz_trackz_2{i}(j,1:2) = [theta rho] ; %subtract stimulus coords from x and y coords

        tranz_trackz{i}(j,1) =     (pre_tranz_trackz_2{i}(j,1) + (pi/2)) -     trial_limits(i,9)    ; %normalised theta
        tranz_trackz{i}(j,2) =      pre_tranz_trackz_2{i}(j,2) /     trial_limits(i,10)   ; %normalised rho
        
        if  tranz_trackz{i}(j,1) < (-2*pi)
            tranz_trackz{i}(j,1) = tranz_trackz{i}(j,1) + (4*pi);
        elseif tranz_trackz{i}(j,1) < 0
            tranz_trackz{i}(j,1) = tranz_trackz{i}(j,1) + (2*pi);
        end
             
        j = j + 1 ;
        end
 
    i = i + 1;
    end
  return(tranz_trackz)
}
```


```{r}
tranz_trackz <- trackz_transform(trackz,trial_limits)  # transform coords to origin and stimulus
head(tranz_trackz)
```


# check that animal tracks start below 0.25 and increase

### Get animal track points closest to rho of 0.25 and 0.5 for each trial

```{r}
circleValues = zeros([length(trial_limits[,1]) 4])    

i = 1; 
while (i <= size(trial_limits, 1)) {

 [~, index] = min(abs(tranz_trackz{i}(:,2) - 0.25)) ;
 circleValues(i,1:2) = tranz_trackz{i}(index, 1:2)  ;
 
 [~, index] = min(abs(tranz_trackz{i}(:,2) - 0.5))  ;
 circleValues(i,3:4) = tranz_trackz{i}(index, 1:2)  ;
 
 i = i + 1  ;
 }
```

### Create cartesian vector from polar inner and outer circle coordinates 

```{r}
intersect_angle1 <- array(numeric(), c(num_trials,1))    
intersect_angle2 <- array(numeric(), c(num_trials,1)) 
which_intersect  <- array(numeric(), c(num_trials,1)) 
```

###JS: The next section was a bit hard to follow, so I cleaned it up a bit

```{r}
for(i = 1:num_trials){
    [inner_x, inner_y] = pol2cart(circleValues(i,1),circleValues(i,2));
    [outer_x, outer_y] = pol2cart(circleValues(i,3),circleValues(i,4));
    animal_vector(i, 1) = inner_x ;  animal_vector(i, 2) = inner_y ;
    animal_vector(i, 3) = outer_x ;  animal_vector(i, 4) = outer_y ;
    slope(i) = (outer_y - inner_y)/(outer_x - inner_x) ;
    animal_direction(i,1) = outer_x - inner_x;
    animal_direction(i,2) = outer_y - inner_y;
    intercept(i) = animal_direction(i,2) - slope(i) * animal_direction(i,1);
### JS: This was "- slope(i) * animal_direction(i,2);" but I believe it should be "- slope(i) * animal_direction(i,1);"
    [xout,yout] = linecirc(slope(i),intercept(i),0,0,1) ;
    circle_intersect(i, 1:2) = xout;
    circle_intersect(i, 3:4) = yout; # find x and y points where line intersects with circle

    #get polar coordinates of intersects
    [theta_target1, rho_target1] = cart2pol(circle_intersect(i,1),circle_intersect(i,3))   ;
    [theta_target2, rho_target2] = cart2pol(circle_intersect(i,2),circle_intersect(i,4))   ;
    intersect_angle1(i) = radtodeg(theta_target1) ; 
    intersect_angle2(i) = radtodeg(theta_target2) ;
        
    ### JS: Instead of the next section being a manual selection, you could
    ### automatically select the intersect that is closest to the outer circle
    ### crossing, e.g. like this:
    dist_to_track(1) = sqrt( (xout(1)-outer_x)^2 + (yout(1)-outer_y)^2 );
    dist_to_track(2) = sqrt( (xout(2)-outer_x)^2 + (yout(2)-outer_y)^2 );
    [~, which_intersect(i)] = min(dist_to_track);
}
```

Get angle for animal in each trial in degrees and put it in animal_angle

```{r}
animal_radian = zeros([num_trials 1]) ;
correct_intersect = zeros([num_trials 2]) ;
animal_angle = zeros([num_trials 1]) ;

for(i = 1:num_trials){
    if  (which_intersect(i) == 1){
        correct_intersect(i,1) = circle_intersect(i,1);
        correct_intersect(i,2) = circle_intersect(i,3);
    } else if (which_intersect(i) == 2){
        correct_intersect(i,1) = circle_intersect(i,2);
        correct_intersect(i,2) = circle_intersect(i,4);
    } else {
        error('Error, must be 1 or 2');
    }
    
    #add animals angle relative to stimulus centre to animal_angle
    animal_radian[i] = cart2pol(correct_intersect(i,1),correct_intersect(i,2));
    animal_angle[i]  = rad2deg(cart2pol(correct_intersect(i,1),correct_intersect(i,2)));
}
```


get the intersect of the tracks with the arena edge
<!-- get_track_intersect(landmarks,animal_track) ; -->

### Apply basic circular statistics to trials (uses radians)
 
<!-- trials_angle_mean = zeros([3 1]); -->
<!-- [mu ul ll] = circ_mean(animal_radian, [], 2) ; -->

```{r}
circ_labels = as.character(1:length(animal_radian));
directions  = circ_plot(animal_radian);
#tracks = circ_plot();
```

### Create csv output with trial number, position and direction in columns

```{r}
animal_radian_col[:,1] = t(animal_radian) ;
animal_radian_col[:,2] = circular::rad(t(animal_radian) ;

# C = {video_name, animal_radian_col[:,1], animal_radian_col[:,2]} ;
write_csv(animal_radian_col, paste0(video_name,''_directions.csv')
```






cart2rho <- function(x,y){
  rho    <- sqrt(x^2 + y^2)
  return(rho)
}

cart2theta <- function(x,y){
  theta  <- atan2(y,x)
  return(theta)
}




