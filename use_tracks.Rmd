---
title: "Use Animal Tracks"
author: "John Kirwan"
date: "30/6/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

### Get data from animal tracks

```{r message=FALSE, warning=FALSE}
library('tidyverse')
library('magrittr')
library('circular')
library('RColorBrewer')
```
Uses stimulus centre and point opposite stimulus centre as markers for the unit circle on arena. Gets complete track from each set of trials, makes a plot and determines headings.

```{r}
folder <- 'F:/sci/PhD/Urchins/Diadema/Tenerife-2016/tracks/'
folder <- 'tracks/'
filez  <- list.files(normalizePath(folder))
# files_df  <- tibble(landmark=list.files(normalizePath(folder))[
#                     grep('*point01.txt$',list.files(normalizePath(folder)))],
#                     track=list.files(normalizePath(folder))[
#                       grep('*point02.txt$',list.files(normalizePath(folder)))])

files_df <- tibble(basename=sub("*_point01.txt", "",  #subset string before exp
                     list.files(normalizePath(folder))[
                     grep('*point01.txt$',list.files(normalizePath(folder)))]))

files_df %<>% mutate(landmark=paste0(basename,"_point01.txt"),
                    track    =paste0(basename,"_point02.txt"))

tail(files_df)
```


```{r}
# are there any (predicted) track names not represented in the file list?
# i.e. landmark files without a matching track file
if(any(!files_df$track    %in% list.files(normalizePath(folder)))){
  stop(print(paste0("The following track file is missing:",
    files_df$track[which(!files_df$track %in% list.files(normalizePath(folder)))]
                    )))
}

# are any track files in the file list without a match in the landmark files?
if(any(!list.files(normalizePath(folder))[grep('*point02.txt$',list.files(
           normalizePath(folder)))] %in% files_df$track)){
  stop(print(paste0("The following track file lacks a counterpart:",
    list.files(normalizePath(folder))[grep('*point02.txt$',list.files(
      normalizePath(folder)))]
        
                    )))
}
```

Try with first file to get the track

```{r}
animal_track = read.delim(normalizePath(paste0(folder,'/',files_df$track[1])),
                          sep="\t", header = FALSE)[,1:3]
names(animal_track) <- c("frame","x","y")
head(animal_track)
```

Try with first file to get the landmarks

```{r}
animal_landmark = read.delim(normalizePath(paste0(folder,'/',files_df$landmark[1])),
                          sep="\t", header = FALSE)[,1:3]
names(animal_landmark) <- c("frame","x","y")
head(animal_landmark)

if(length(animal_landmark$x) %% 2 == 1){ warning("Odd number of landmarks!") }

num_trials = length(animal_landmark$x)/2 
```


## The files 

With the assignment pipe *%<>%*, the variable is assigned to itself at the end.The radius of the circle based on the stimulus distance is *r_px*.

```{r}
#function [trial_limits] = get_trial_limits(landmarks,animal_track)
get_trial_limits <- function(landmarks,animal_track,file_tbl,vid_num){ #,

 num_trials = dim(landmarks)[1]/2 # count number of trials
 # pick out start frame and centre and stimulus coords
 trial_limits <- as_tibble(array(0,dim=c(num_trials,16),
    dimnames = list(NULL, c("first_f","orig_x","orig_y","stim_x","stim_y",
    "last_f","norm_stim_x","norm_stim_y","theta","r_px","quadrant","video",
    "x0","y0","x1","y1"))), 
    .name_repair="unique")
  
  trial_limits$video <- as.character(trial_limits$video)
  i = 1 
  
 while (i <= num_trials){ # for each trial
   trial_limits[i, 1  ] <- as.numeric(landmarks[(i*2)-1,  1]) # trial i start frame
   trial_limits[i, 2:3] <- as.list(as.numeric(landmarks[(i*2)-1,2:3])) # trial i centre pt x,y
   trial_limits[i, 4:5] <- as.list(as.numeric(landmarks[i*2,    2:3])) # trial i stim centre x,y
    
     if (i < num_trials){
        trial_limits[i , 6] <- as.numeric(landmarks[((i+1)*2)-1,1] - 1)  # trial i last frame
     } else {
       j =  max(animal_track[,1]) # max along dimension 1 - which I tak to mean the 1st col
       trial_limits[i , 6] = j[1]
     }
 
     trial_limits[i , 7:8] <- as.list(as.numeric(trial_limits[i, 4:5] - trial_limits[i , 2:3])) 
     # normalised stimulus centre in cartesian terms relative to centre of arena
     theta1 = atan2(trial_limits[[i,8]],trial_limits[[i , 7]]) # polars for stimulus centre
     rho1   = sqrt(trial_limits[[i, 7]]^2 + trial_limits[[i,8]]^2)
     
     theta1 = theta1 + pi/2; # set to conventional degree values with 0 at top and clockwise
     if (theta1 < 0){        
         theta1 = theta1 + pi*2;     
     }else if (theta1 > pi*2){   
         theta1 = theta1 - pi*2     
     }
     trial_limits[i , 9] = theta1; 
     trial_limits[i , 10] <- rho1 # theta in rads, rho in pixels

    if (trial_limits[i , 9] >= 0 & trial_limits[i , 9] < pi/4 | trial_limits[i , 9] > 1.75*pi){ 
     #if stimulus in first quadrant
        trial_limits[i , 11] = 1;
    }else if (trial_limits[i , 9] >= pi/4    & trial_limits[i , 9] < 0.75*pi ){
        trial_limits[i , 11] = 2;
    }else if (trial_limits[i , 9] >= 0.75*pi & trial_limits[i , 9] < 1.25*pi ){
        trial_limits[i , 11] = 3;
    }else if (trial_limits[i , 9] >= 1.25*pi & trial_limits[i , 9] < 1.75*pi ){
        trial_limits[i , 11] <- 4;
    }
    trial_limits[i, 12]      <- file_tbl[[vid_num,1]];
    i = i + 1 
 }
 return(trial_limits)
}
```

#find each trial and get data
# (i) frame no (ii - v) coords for centre and stimulus (vi) last frame #
# (vii - viii) normalised stimulus centre (ix) theta in rads (anticlock,
# zero=0) (x) rho in pixels 

Get limits from first video

```{r}
trial_limits <- get_trial_limits(animal_landmark,animal_track,files_df,1) #
```


Divide the animal tracks up by trial using the first landmark. Initialize 
transformed tracks for later.

```{r Get animal pos fx}
get_animal_pos <- function(trial_limits,animal_track){
  num_trials = dim(trial_limits)[1] # count number of trials
  
  # make nested tibble of the sets
  trackz <- purrr::map(vector(length=num_trials), tibble)

 i <- 1 # initialize i  
 while (i <= dim(trial_limits)[1]){    # for each trial in a video 
   animal_track$trial_num[ animal_track$frame >= trial_limits[[i,1]] & 
        animal_track$frame <= trial_limits[[i,6]] ] <- i # get the trial no for each obs
   XY <- as_tibble(animal_track[animal_track$frame >= trial_limits[[i,1]] & 
           animal_track$frame <= trial_limits[[i,6]],]) # make a tibble of that trial
   #XY[,5] <- trial_limits[[i,12]]
   XY %<>% add_column(trans_x=0,trans_y=0,trans_theta=0,trans_rho=0)
   XY[,5:6] <- sweep(XY[,2:3],2,as.numeric(trial_limits[i,2:3]),"-")
   
   trans_theta <- mapply(atan2,XY[,6],XY[,5]) # polars for stim centre
   trans_rho   <- sqrt(XY[,5]^2 + XY[,6]^2)
   
   XY[,7] <- trans_theta + (pi/2) - as.numeric(trial_limits[i,9]) # norm theta
   XY[,7] <- as.circular(XY[,7],type="angles",units="radians")
   XY[,8] <- trans_rho / as.numeric(trial_limits[i,10]) #normalised rho
        
   XY$trans_theta[XY$trans_theta>pi] <- XY$trans_theta[XY$trans_theta>pi] - 2*pi
   trackz[[i]] <- XY
   # assign tracks less than 40% of arena to be empty
   if(min(XY[,8])>.4){trackz[[i]] <- "Track starts too far from centre"}
   if(any(XY[,8])> 1){warning('Track exceeds arena width!')}
   
#if(!any(XY[,8] < .25)){warning(paste0("Tracks begin >1/4 rad from centre for trial"))}
   trial_limits[i,13] <- XY$trans_x[which.min(abs(XY$trans_rho - .25))]
   trial_limits[i,14] <- XY$trans_y[which.min(abs(XY$trans_rho - .25))]
   trial_limits[i,15] <- XY$trans_x[which.min(abs(XY$trans_rho - .5))]
   trial_limits[i,16] <- XY$trans_y[which.min(abs(XY$trans_rho - .5))]
   i = i + 1
 }
 #trial_limits[,13:16] <- mapply('/',trial_limits[,13:16], trial_limits[,10])
 # norm to radius
 return(list(trackz,trial_limits))
}
```

Get the all the tracks from a single file. Print one set.

```{r}
trial_track_list   <- get_animal_pos(trial_limits,animal_track)
trackz             <- trial_track_list[[1]]
tail(trackz[[1]])
```

```{r}
trial_limits      <- trial_track_list[[2]]
tail(trial_limits)
```

Now apply this to all files.Then transform the coords from all tibbles in the big list.


```{r}
get_all_animal_pos <- function(animal_landmark,animal_track,files_df){
  # for all files in files_df
  i <- 1
  while(i <= dim(files_df)[1]){
    animal_track = read.delim(normalizePath(paste0(folder,'/',files_df$track[i])),
                            sep="\t", header = FALSE)[,1:3]
    names(animal_track) <- c("frame","x","y")
  
    animal_landmark = read.delim(normalizePath(paste0(folder,'/',
                      files_df$landmark[i])),sep="\t", header = FALSE)[,1:3]
    names(animal_landmark) <- c("frame","x","y")
    if(length(animal_landmark$x) %% 2 == 1){ warning("Odd number of landmarks!") }
    trial_limits <- get_trial_limits(animal_landmark,animal_track,files_df,i) #
    # run get_animal_pos
    trial_track_list <- get_animal_pos(trial_limits,animal_track) 

     if(i == 1){  
       all_trackz       <- trial_track_list[[1]] # populate with first list
       all_trial_limits <- trial_track_list[[2]] # first instance from above
     } else {
       all_trackz       <- c(all_trackz,trial_track_list[[1]])
       all_trial_limits <- rbind(all_trial_limits,trial_track_list[[2]])
    }
    i <- i + 1
  }
 trackz_n_limits <- list(all_trackz,all_trial_limits) 
 return(trackz_n_limits)
}
```


```{r}
trackz_n_limits  <- get_all_animal_pos(animal_landmark,animal_track,files_df)
all_trackz       <- trackz_n_limits[[1]]
tail(all_trackz[[1]])
```

Delete tracks which have no points less than 40% of the way across the arena.

```{r}
all_trial_limits <- trackz_n_limits[[2]]
tail(all_trial_limits)
```

This should go in the function. Normalize the trial limits by the radius.

```{r}
all_trial_limits[,13:16] <- mapply('/', all_trial_limits[,13:16], all_trial_limits[,10])
```

Delete those rows for which the first and second circles are the same.

```{r}
idx <- which(all_trial_limits$x0==all_trial_limits$x1 & all_trial_limits$y0==all_trial_limits$y1)
all_trackz[idx] <- NULL
all_trial_limits <- all_trial_limits[-c(idx),]
print(paste(length(all_trackz),"tracks post culling"))
print(paste(dim(all_trial_limits)[1],"trials in limits list post culling"))
```

Make tibble for tracks rather than list

```{r}
trackz_tbl <- map_dfr(all_trackz, ~ .x)
```


Write the tracks to a file

```{r}
write_csv(trackz_tbl,  file = "tracks_file.csv")
write_delim(trackz_tbl,file = "tracks_file.txt",delim = "\t")
```



Line-Circle Intercept.

Works when vector intersects circle.

```{r}
linecirc <- function(x0,y0,x1,y1){
  h = 0;k=0;radius=1 # circle origin x,y
  a = (x1 - x0)^2 + (y1 - y0)^2 # vector length
  b = (2*(x1 - x0)*(x0 - h)) + (2*(y1 - y0)*(y0 - k)) # 
  c = (x0 - h)^2 + (y0 - k)^2 - radius^2
  D <- (b^2) - (4*a*c) # discriminant - must be positive
  if(a <= 0){warning("Vector length is not positive!")}
  if(D <= 0){warning(paste0(
    "Discriminant is not positive with x0=",x0," y0=",y0," x1=",x1," y1=",y1))}
  if(c >= 0){warning("Starting pt is outside radius!")}
  
  # the roots for t may be found in the usual quadratic form:
  t <- c(0,0)
  t[1] = (-b + sqrt(D)) / (2*a)
  t[2] = (-b - sqrt(D)) / (2*a) 
  # 1st and 2nd rows of ints correspond to 1st and 2nd root respectively
  ints <- rbind(unlist(c( t[1]*(x1 - x0) + x0, t[1]*(y1 - y0) + y0)),
                unlist(c( t[2]*(x1 - x0) + x0, t[2]*(y1 - y0) + y0)))
            
  d <- c(sqrt(ints[1,1]^2 + ints[1,2]^2),sqrt(ints[2,1]^2 + ints[2,2]^2))
  if(all.equal(d[1],d[2])==FALSE){warning("Intersect is off unit circle!")}
  # 1st and 2nd rows of dist2track correspond to 1st and 2nd root respectively
  dist2track    <- c(0,0) 
  dist2track[1] <- sqrt( (ints[1,1]-x1)^2 + (ints[1,2]-y1)^2 )
  dist2track[2] <- sqrt( (ints[2,1]-x1)^2 + (ints[2,2]-y1)^2 )
  xy <- ints[which.min(dist2track),]
  
  # commented because NAs crash this part
  #if(t[1] < 1 | t[2] > 0){ #which.min(dist2track)
  #  warning('Roots imply vector is weird') }
  return(tibble::tibble(x_int = xy[1],y_int = xy[2])) # return closest to outer pt
}
```



```{r}
all_trial_limits[,17:18] <- pmap_dfr(list(
  all_trial_limits$x0,all_trial_limits$y0,
                    all_trial_limits$x1,all_trial_limits$y1), linecirc)
```


With code modified from Dr. James J. Foster.

```{r}
rad_plot <- function(x, alpha, ax, rho.col, out.by, kappa.ci, ...){
  require('circular')
	if(missing(ax)){ax <- F} #fit mean axis (not direction)
	if(missing(rho.col)){rho.col <- 'deeppink4'}#fit mean axis (not direction)
	if(missing(out.by)){out.by = 0.05} # draw outside (or inside) by
	if(missing(alpha)){alpha = 0.05} #proportion NOT to plot across
		#spacing of stacked points, now automatically stacks towards centre unless otherwise specified
	if(missing(kappa.ci)){kappa.ci = F} #proportion NOT to plot across
		#spacing of stacked points, now automatically stacks towards centre unless otherwise specified
	sp <- 0.07
		if(!(	sum('mycirc'%in% ls())	)){
		mycirc <- function(angles, clock){
			if(missing(clock)){clock <- T}
			if(clock){
			return(		as.circular(angles,units='radians',type='angles',
			modulo='2pi',zero=pi/2,rotation='clock',	template='none')	)
				}else{
				as.circular(angles,units='radians',type='angles',
				 modulo='2pi',zero=pi/2,rotation='counter',template='none')
	}}}
	if(ax == F){
			#circular plot settings
	zr <- pi/2 #start at top of screen (pi*	90	/180)
	bn <- 10*10*360/5 #bins
	tcl <- rgb(1,1,1,0)#transparent colour
	pcl <- rgb(.3,.1,.1,.5)#point colour
	#plot characters
	lw <- 0.5 #line width
	pnt <- 2.5 #point size
	arw <- 10 #arrowhead angle
	arl <- 0.01 #arrowhead length
	#	set up input variables
	hd <- as.circular(x,units='radians',type='angles',
			modulo='2pi',zero=pi/2,rotation='clock',	template='none')
	sm <- summary(hd)
	sv <- sd.circular(hd, na.rm=T)
	lbl   <- c(0,pi)
	plot(hd, col=tcl, main="", zero=zr, axes=F, shrink=1,tol=0.075)
	axis.circular(1, at = mycirc(c(0,pi)), labels = c("0","180"))
	par(new=T)
	plot.circular(hd, col=tcl,main="",zero=zr,axes=F,shrink=1.05,tol=0.075)
	points(hd,stack=T,bin=bn,sep=-sp,zero=zr,...)
	par(new=T)
	plot(hd, col=tcl, main="", zero=zr, axes=F, shrink=1,tol=0.075)
	if(kappa.ci){
	lines.circular(mycirc(rep(mean(hd, na.rm =T),2)), 
	               y = -(1-A1(mle.vonmises.bootstrap.ci(hd, alpha = 0.05, bias = T, reps = 10^4)$kappa.ci)), col = rgb(1,0,0,0.2), lwd = 7, lend = 'butt')
	}#if(kappa.ci)
	arrows.circular( mean(hd, na.rm =T),zero=zr, col = rho.col,lwd=3,
		 length=arl,angle=arw,shrink = .95 * rho.circular(hd,na.rm =T))
	#find the lower and upper confidence interval bounds
	ci <- mle.vonmises.bootstrap.ci(hd, alpha = alpha, bias = T,
          reps = 10^4)$mu.ci
	if(sign(max(ci) - mean(hd, na.rm =T)) == -1 | sign(mean(hd, na.rm =T) - min(ci)) == -1 ){#check if mean is right or left of max CI
		#otherwise, plot in the reverse direction
		sq = seq( from = as.numeric(min(ci)),
					to = -as.numeric(2*pi - max(ci)), length.out = 10^3)
		}else{ #if it is "little" plot from min to max
		sq = seq( from = as.numeric(min(ci)),
					to = as.numeric(max(ci)), length.out = 10^3)
	}#if(abs(diff(qt)) > pi)
	lines.circular(mycirc(sq), rep(out.by,10^3), col = rho.col, lwd = 3)
	}#if(ax == F)
}
```


Use atan2 to get the headings in radians. Then, having changed the class to circular, set them so that 0 refers to the stimulus midpoint and the rotation is clockwise. 

```{r}
all_trial_limits[,19]<-mapply(atan2, all_trial_limits[,18],all_trial_limits[,17])
colnames(all_trial_limits)[19] <- "radians"
all_trial_limits$radians <- as.circular(all_trial_limits$radians, type="angles",
                            units="radians",zero=0,rotation="counter",
                            template="none", modulo="asis")
all_trial_limits$radians <- conversion.circular(all_trial_limits$radians,   
                            zero=pi/2,rotation="clock")
rad_plot(all_trial_limits$radians)
title(main="Plot all headings")
```
Temporary fix - remove observations with rho value greater than 1

```{r}
trackz_tbl <- trackz_tbl[trackz_tbl$trans_rho <= 1,]
```


#### Plotting

For some reason it appears to be using the conventional unit circle zero and rotation (points concentrated at x=1,y=0).

Later, use scale_colour_brewer(palette = "Paired")

```{r}
trackz_tbl %>% #group_by(video)
  ggplot() + coord_fixed() +
  geom_point(aes(x=trans_rho*cos(trans_theta),y=trans_rho*sin(trans_theta)),
             alpha=1, size=.7) + 
  annotate("path",
  x=0+1*cos(seq(0,2*pi,length.out=100)),y=0+1*sin(seq(0,2*pi,length.out=100))) +
  annotate("path", color="blue",
  x=0+.5*cos(seq(0,2*pi,length.out=100)),y=0+.5*sin(seq(0,2*pi,length.out=100))) +
  annotate("path", color="orange",
  x=0+.25*cos(seq(0,2*pi,length.out=100)),y=0+.25*sin(seq(0,2*pi,length.out=100))) +
  xlab('') + ylab('') + theme_classic() + ggtitle('Plot all tracks simultaneously') +
  theme(axis.line=element_blank(),axis.ticks=element_blank(),
        axis.text=element_blank()) + scale_colour_brewer(palette = "Paired") +
  scale_fill_brewer(palette = "Paired")
```




